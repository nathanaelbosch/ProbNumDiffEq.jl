<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Second Order ODEs and Energy Preservation · ProbNumDiffEq.jl</title><meta name="title" content="Second Order ODEs and Energy Preservation · ProbNumDiffEq.jl"/><meta property="og:title" content="Second Order ODEs and Energy Preservation · ProbNumDiffEq.jl"/><meta property="twitter:title" content="Second Order ODEs and Energy Preservation · ProbNumDiffEq.jl"/><meta name="description" content="Documentation for ProbNumDiffEq.jl."/><meta property="og:description" content="Documentation for ProbNumDiffEq.jl."/><meta property="twitter:description" content="Documentation for ProbNumDiffEq.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ProbNumDiffEq.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Second Order ODEs and Energy Preservation</a><ul class="internal"><li><a class="tocitem" href="#Simulating-the-Hénon-Heiles-system"><span>Simulating the Hénon-Heiles system</span></a></li><li><a class="tocitem" href="#Energy-preservation"><span>Energy preservation</span></a></li></ul></li><li><a class="tocitem" href="../dae/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../exponential_integrators/">Probabilistic Exponential Integrators</a></li><li><a class="tocitem" href="../fenrir/">Parameter Inference</a></li></ul></li><li><span class="tocitem">Solvers and Options</span><ul><li><a class="tocitem" href="../../solvers/">Solvers</a></li><li><a class="tocitem" href="../../priors/">Priors</a></li><li><a class="tocitem" href="../../initialization/">Initialization</a></li><li><a class="tocitem" href="../../diffusions/">Diffusion models and calibration</a></li></ul></li><li><span class="tocitem">Benchmarks</span><ul><li><a class="tocitem" href="../../benchmarks/multi-language-wrappers/">Multi-Language Wrapper Benchmark</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Non-stiff ODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../benchmarks/lotkavolterra/">Lotka-Volterra</a></li><li><a class="tocitem" href="../../benchmarks/hodgkinhuxley/">Hodgkin-Huxley</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Stiff ODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../benchmarks/vanderpol/">Van der Pol</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Second-order ODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../benchmarks/pleiades/">Pleiades</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Differential-Algebraic Equations (DAEs)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../benchmarks/orego/">OREGO</a></li><li><a class="tocitem" href="../../benchmarks/rober/">ROBER</a></li></ul></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../../filtering/">Filtering and Smoothing</a></li><li><a class="tocitem" href="../../implementation/">Implementation via OrdinaryDiffEq.jl</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Second Order ODEs and Energy Preservation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Second Order ODEs and Energy Preservation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/nathanaelbosch/ProbNumDiffEq.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/nathanaelbosch/ProbNumDiffEq.jl/blob/main/docs/src/tutorials/dynamical_odes.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Second-Order-ODEs-and-Energy-Preservation"><a class="docs-heading-anchor" href="#Second-Order-ODEs-and-Energy-Preservation">Second Order ODEs and Energy Preservation</a><a id="Second-Order-ODEs-and-Energy-Preservation-1"></a><a class="docs-heading-anchor-permalink" href="#Second-Order-ODEs-and-Energy-Preservation" title="Permalink"></a></h1><p>In this tutorial we consider an <em>energy-preserving</em>, physical dynamical system, given by a <em>second-order</em> ODE.</p><h4 id="TL;DR:"><a class="docs-heading-anchor" href="#TL;DR:">TL;DR:</a><a id="TL;DR:-1"></a><a class="docs-heading-anchor-permalink" href="#TL;DR:" title="Permalink"></a></h4><ol><li>To <em>efficiently</em> solve second-order ODEs, just define the problem as a <code>SecondOrderODEProblem</code>.</li><li>To preserve constant quantities, use the <code>ManifoldUpdate</code> callback; same syntax as <a href="https://docs.sciml.ai/DiffEqCallbacks/stable/projection/">DiffEqCallback.jl&#39;s <code>ManifoldProjection</code></a>.</li></ol><h2 id="Simulating-the-Hénon-Heiles-system"><a class="docs-heading-anchor" href="#Simulating-the-Hénon-Heiles-system">Simulating the Hénon-Heiles system</a><a id="Simulating-the-Hénon-Heiles-system-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-the-Hénon-Heiles-system" title="Permalink"></a></h2><p>The Hénon-Heiles model describes the motion of a star around a galactic center, restricted to a plane. It is given by a second-order ODE</p><p class="math-container">\[\begin{aligned}
\ddot{x} &amp;= - x - 2 x y \\
\ddot{y} &amp;= y^2 - y - x^2.
\end{aligned}\]</p><p>Our goal is to numerically simulate this system on a time span <span>$t \in [0, T]$</span>, starting with initial values <span>$x(0)=0$</span>, <span>$y(0) = 0.1$</span>, <span>$\dot{x}(0) = 0.5$</span>, <span>$\dot{y}(0) = 0$</span>.</p><h3 id="Transforming-the-problem-into-a-first-order-ODE"><a class="docs-heading-anchor" href="#Transforming-the-problem-into-a-first-order-ODE">Transforming the problem into a first-order ODE</a><a id="Transforming-the-problem-into-a-first-order-ODE-1"></a><a class="docs-heading-anchor-permalink" href="#Transforming-the-problem-into-a-first-order-ODE" title="Permalink"></a></h3><p>A very common approach is to first transform the problem into a first-order ODE by introducing a new variable</p><p class="math-container">\[u = [dx,dy,x,y],\]</p><p>to obtain</p><p class="math-container">\[\begin{aligned}
\dot{u}_1(t) &amp;= - u_3 - 2 u_3 u_4 \\
\dot{u}_2(t) &amp;= u_4^2 - u_4 - u_4^2 \\
\dot{u}_3(t) &amp;= u_1 \\
\dot{u}_4(t) &amp;= u_2.
\end{aligned}\]</p><p>This first-order ODE can then be solved using any conventional ODE solver - including our <code>EK1</code>:</p><pre><code class="language-julia hljs">using ProbNumDiffEq, Plots

function Hénon_Heiles(du, u, p, t)
    du[1] = -u[3] - 2 * u[3] * u[4]
    du[2] = u[4]^2 - u[4] - u[3]^2
    du[3] = u[1]
    du[4] = u[2]
end
u0, du0 = [0.0, 0.1], [0.5, 0.0]
tspan = (0.0, 100.0)
prob = ODEProblem(Hénon_Heiles, [du0; u0], tspan)
sol = solve(prob, EK1());
plot(sol, idxs=(3, 4)) # where `idxs=(3,4)` is used to plot x agains y</code></pre><img src="d729f2ec.svg" alt="Example block output"/><h3 id="Solving-the-second-order-ODE-directly"><a class="docs-heading-anchor" href="#Solving-the-second-order-ODE-directly">Solving the second-order ODE directly</a><a id="Solving-the-second-order-ODE-directly-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-second-order-ODE-directly" title="Permalink"></a></h3><p>Instead of first transforming the problem, we can also solve it directly as a second-order ODE, by defining it as a <code>SecondOrderODEProblem</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>SecondOrderODEProblem</code> type is not defined in ProbNumDiffEq.jl but is provided by SciMLBase.jl. For more information, check out the DifferentialEquations.jl documentation on <a href="https://diffeq.sciml.ai/stable/types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a>.</p></div></div><pre><code class="language-julia hljs">function Hénon_Heiles2(ddu, du, u, p, t)
    ddu[1] = -u[1] - 2 * u[1] * u[2]
    ddu[2] = u[2]^2 - u[2] - u[1]^2
end
prob2 = SecondOrderODEProblem(Hénon_Heiles2, du0, u0, tspan)
sol2 = solve(prob2, EK1());
plot(sol2, idxs=(3, 4))</code></pre><img src="2f0cc02e.svg" alt="Example block output"/><h3 id="Benchmark:-Solving-second-order-ODEs-is-*faster*"><a class="docs-heading-anchor" href="#Benchmark:-Solving-second-order-ODEs-is-*faster*">Benchmark: Solving second order ODEs is <em>faster</em></a><a id="Benchmark:-Solving-second-order-ODEs-is-*faster*-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark:-Solving-second-order-ODEs-is-*faster*" title="Permalink"></a></h3><p>Solving second-order ODEs is not just a matter of convenience - in fact, SciMLBase&#39;s <code>SecondOrderODEProblem</code> is neatly designed in such a way that all the classic solvers from OrdinaryDiffEq.jl can handle it by solving the corresponding first-order ODE. But, transforming the ODE to first order increases the dimensionality of the problem, and comes therefore at increased computational cost; this also motivates <a href="https://diffeq.sciml.ai/stable/solvers/dynamical_solve/">classic specialized solvers for second-order ODEs</a>.</p><p>The probabilistic numerical solvers from ProbNumDiffEq.jl have the same internal state representation for first and second order ODEs; all that changes is the <em>measurement model</em> [<a href="../../references/#bosch22pickandmix">1</a>]. As a result, we can use the <code>EK1</code> both for first and second order ODEs, but it automatically specializes on the latter to provide a <strong>2x performance boost</strong>:</p><pre><code class="nohighlight hljs">julia&gt; @btime solve(prob, EK1(order=3), adaptive=false, dt=1e-2);
  766.312 ms (400362 allocations: 173.38 MiB)

julia&gt; @btime solve(prob2, EK1(order=4), adaptive=false, dt=1e-2);
  388.301 ms (510676 allocations: 102.78 MiB)</code></pre><h2 id="Energy-preservation"><a class="docs-heading-anchor" href="#Energy-preservation">Energy preservation</a><a id="Energy-preservation-1"></a><a class="docs-heading-anchor-permalink" href="#Energy-preservation" title="Permalink"></a></h2><p>In addition to the ODE given above, we know that the solution of the Hénon-Heiles model has to <em>preserve energy</em> over time. The total energy can be expressed as the sum of the potential and kinetic energies, given by</p><p class="math-container">\[\begin{aligned}
\operatorname{PotentialEnergy}(x,y) &amp;= \frac{1}{2} \left( x^2 + y^2 + 2 x^2 y - \frac{2y^3}{3} \right), \\
\operatorname{KineticEnergy}(\dot{x}, \dot{y}) &amp;= \frac{1}{2} \left( \dot{x}^2 + \dot{y}^2 \right).
\end{aligned}\]</p><p>In code:</p><pre><code class="language-julia hljs">PotentialEnergy(x, y) = 1 // 2 * (x^2 + y^2 + 2x^2 * y - 2 // 3 * y^3)
KineticEnergy(dx, dy) = 1 // 2 * (dx^2 + dy^2)
E(dx, dy, x, y) = PotentialEnergy(x, y) + KineticEnergy(dx, dy)
E(u) = E(u...); # convenient shorthand</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">E (generic function with 2 methods)</code></pre><p>Let&#39;s have a look at how the total energy changes over time when we numerically simulate the Hénon-Heiles model over a long period of time: Standard solve</p><pre><code class="language-julia hljs">longprob = remake(prob2, tspan=(0.0, 1e3))
longsol = solve(longprob, EK1(smooth=false), dense=false)
plot(longsol.t, E.(longsol.u))</code></pre><img src="6d032963.svg" alt="Example block output"/><p>It visibly loses energy over time, from an initial 0.12967 to a final 0.12899. Let&#39;s fix this to get a physically more meaningful solution.</p><h3 id="Energy-preservation-with-the-ManifoldUpdate-callback"><a class="docs-heading-anchor" href="#Energy-preservation-with-the-ManifoldUpdate-callback">Energy preservation with the <code>ManifoldUpdate</code> callback</a><a id="Energy-preservation-with-the-ManifoldUpdate-callback-1"></a><a class="docs-heading-anchor-permalink" href="#Energy-preservation-with-the-ManifoldUpdate-callback" title="Permalink"></a></h3><p>In the language of ODE filters, preserving energy over time amounts to just another measurement model [<a href="../../references/#bosch22pickandmix">1</a>]. The most convenient way of updating on this additional zero measurement with ProbNumDiffEq.jl is with the <code>ManifoldUpdate</code> callback.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>ManifoldUpdate</code> callback can be thought of a probabilistic counterpart to the <a href="https://diffeq.sciml.ai/stable/features/callback_library/#Manifold-Conservation-and-Projection"><code>ManifoldProjection</code></a> callback provided by DiffEqCallbacks.jl.</p></div></div><p>To do so, first define a (vector-valued) residual function, here chosen to be the difference between the current energy and the initial energy, and build a <code>ManifoldUpdate</code> callback</p><pre><code class="language-julia hljs">residual(u) = [E(u) - E(du0..., u0...)]
cb = ManifoldUpdate(residual)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DiscreteCallback{ProbNumDiffEq.var&quot;#condition#56&quot;, ProbNumDiffEq.var&quot;#affect!#57&quot;{Int64, Float64, Float64, typeof(Main.residual)}, typeof(SciMLBase.INITIALIZE_DEFAULT), typeof(SciMLBase.FINALIZE_DEFAULT)}(ProbNumDiffEq.var&quot;#condition#56&quot;(), ProbNumDiffEq.var&quot;#affect!#57&quot;{Int64, Float64, Float64, typeof(Main.residual)}(100, 1.0e-25, 1.0e-15, Main.residual), SciMLBase.INITIALIZE_DEFAULT, SciMLBase.FINALIZE_DEFAULT, Bool[1, 1])</code></pre><p>Then, solve the ODE with this callback</p><pre><code class="language-julia hljs">longsol_preserving = solve(longprob, EK1(smooth=false), dense=false, callback=cb)
plot(longsol.t, E.(longsol.u))
plot!(longsol_preserving.t, E.(longsol_preserving.u))</code></pre><img src="e1f3dd0b.svg" alt="Example block output"/><p>Voilà! With the <code>ManifoldUpdate</code> callback we could preserve the energy over time and obtain a more truthful probabilistic numerical long-term simulation of the Hénon-Heiles model.</p><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><div class="citation noncanonical"><dl><dt>[1]</dt><dd><div>N. Bosch, F. Tronarp and P. Hennig. <a href="https://proceedings.mlr.press/v151/bosch22a.html"><em>Pick-and-Mix Information Operators for Probabilistic ODE                   Solvers</em></a>. In: <em>Proceedings of The 25th International Conference on Artificial                   Intelligence and Statistics</em>, Vol. 151 of <em>Proceedings of Machine Learning Research</em>, edited by G. Camps-Valls, F. J. Ruiz and I. Valera (PMLR, 28–30 Mar 2022); pp. 10015–10027.</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting Started</a><a class="docs-footer-nextpage" href="../dae/">Differential Algebraic Equations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 12 December 2023 16:52">Tuesday 12 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
