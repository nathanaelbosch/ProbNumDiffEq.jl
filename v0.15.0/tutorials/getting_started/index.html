<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · ProbNumDiffEq.jl</title><meta name="title" content="Getting Started · ProbNumDiffEq.jl"/><meta property="og:title" content="Getting Started · ProbNumDiffEq.jl"/><meta property="twitter:title" content="Getting Started · ProbNumDiffEq.jl"/><meta name="description" content="Documentation for ProbNumDiffEq.jl."/><meta property="og:description" content="Documentation for ProbNumDiffEq.jl."/><meta property="twitter:description" content="Documentation for ProbNumDiffEq.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ProbNumDiffEq.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Getting Started</a><ul class="internal"><li><a class="tocitem" href="#TL;DR:-Just-use-DifferentialEquations.jl-with-the-EK1-algorithm"><span>TL;DR: Just use DifferentialEquations.jl with the <code>EK1</code> algorithm</span></a></li><li><a class="tocitem" href="#Step-1:-Define-the-problem"><span>Step 1: Define the problem</span></a></li><li><a class="tocitem" href="#Step-2:-Solve-the-problem"><span>Step 2: Solve the problem</span></a></li><li><a class="tocitem" href="#Step-3:-Analyze-the-solution"><span>Step 3: Analyze the solution</span></a></li><li><a class="tocitem" href="#Next-steps"><span>Next steps</span></a></li></ul></li><li><a class="tocitem" href="../dynamical_odes/">Second Order ODEs and Energy Preservation</a></li><li><a class="tocitem" href="../dae/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../exponential_integrators/">Probabilistic Exponential Integrators</a></li><li><a class="tocitem" href="../ode_parameter_inference/">Parameter Inference</a></li></ul></li><li><span class="tocitem">Solvers and Options</span><ul><li><a class="tocitem" href="../../solvers/">Solvers</a></li><li><a class="tocitem" href="../../priors/">Priors</a></li><li><a class="tocitem" href="../../initialization/">Initialization</a></li><li><a class="tocitem" href="../../diffusions/">Diffusion models and calibration</a></li></ul></li><li><a class="tocitem" href="../../likelihoods/">Data Likelihoods</a></li><li><span class="tocitem">Benchmarks</span><ul><li><a class="tocitem" href="../../benchmarks/multi-language-wrappers/">Multi-Language Wrapper Benchmark</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Non-stiff ODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../benchmarks/lotkavolterra/">Lotka-Volterra</a></li><li><a class="tocitem" href="../../benchmarks/hodgkinhuxley/">Hodgkin-Huxley</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Stiff ODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../benchmarks/vanderpol/">Van der Pol</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Second-order ODEs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../benchmarks/pleiades/">Pleiades</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Differential-Algebraic Equations (DAEs)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../benchmarks/orego/">OREGO</a></li><li><a class="tocitem" href="../../benchmarks/rober/">ROBER</a></li></ul></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../../filtering/">Filtering and Smoothing</a></li><li><a class="tocitem" href="../../implementation/">Implementation via OrdinaryDiffEq.jl</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/nathanaelbosch/ProbNumDiffEq.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/nathanaelbosch/ProbNumDiffEq.jl/blob/main/docs/src/tutorials/getting_started.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Solving-ODEs-with-Probabilistic-Numerics"><a class="docs-heading-anchor" href="#Solving-ODEs-with-Probabilistic-Numerics">Solving ODEs with Probabilistic Numerics</a><a id="Solving-ODEs-with-Probabilistic-Numerics-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-ODEs-with-Probabilistic-Numerics" title="Permalink"></a></h1><p>In this tutorial we solve a simple non-linear ordinary differential equation (ODE) with the <em>probabilistic numerical</em> ODE solvers implemented in this package.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you never used DifferentialEquations.jl, check out their <a href="https://docs.sciml.ai/DiffEqDocs/stable/getting_started/">&quot;Getting Started with Differential Equations in Julia&quot; tutorial</a>. It explains how to define and solve ODE problems and how to analyze the solution, so it&#39;s a great starting point. Most of ProbNumDiffEq.jl works exactly as you would expect from DifferentialEquations.jl – just with some added uncertainties and related functionality on top!</p></div></div><p>In this tutorial, we consider a <a href="https://en.wikipedia.org/wiki/FitzHugh%E2%80%93Nagumo_model">Fitzhugh-Nagumo model</a> described by an ODE of the form</p><p class="math-container">\[\begin{aligned}
\dot{y}_1 &amp;= c (y_1 - \frac{y_1^3}{3} + y_2) \\
\dot{y}_2 &amp;= -\frac{1}{c} (y_1 - a - b y_2)
\end{aligned}\]</p><p>on a time span <span>$t \in [0, T]$</span>, with initial value <span>$y(0) = y_0$</span>. In the following, we</p><ol><li>define the problem with explicit choices of initial values, integration domains, and parameters,</li><li>solve the problem with our ODE filters, and</li><li>visualize the results and the corresponding uncertainties.</li></ol><h2 id="TL;DR:-Just-use-DifferentialEquations.jl-with-the-EK1-algorithm"><a class="docs-heading-anchor" href="#TL;DR:-Just-use-DifferentialEquations.jl-with-the-EK1-algorithm">TL;DR: Just use DifferentialEquations.jl with the <code>EK1</code> algorithm</a><a id="TL;DR:-Just-use-DifferentialEquations.jl-with-the-EK1-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#TL;DR:-Just-use-DifferentialEquations.jl-with-the-EK1-algorithm" title="Permalink"></a></h2><pre><code class="language-julia hljs">using ProbNumDiffEq, Plots

function fitz(du, u, p, t)
    a, b, c = p
    du[1] = c * (u[1] - u[1]^3 / 3 + u[2])
    du[2] = -(1 / c) * (u[1] - a - b * u[2])
end
u0 = [-1.0; 1.0]
tspan = (0.0, 20.0)
p = (0.2, 0.2, 3.0)
prob = ODEProblem(fitz, u0, tspan, p)

sol = solve(prob, EK1())
plot(sol)</code></pre><img src="74422525.svg" alt="Example block output"/><h2 id="Step-1:-Define-the-problem"><a class="docs-heading-anchor" href="#Step-1:-Define-the-problem">Step 1: Define the problem</a><a id="Step-1:-Define-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Define-the-problem" title="Permalink"></a></h2><p>First, import ProbNumDiffEq.jl</p><pre><code class="language-julia hljs">using ProbNumDiffEq</code></pre><p>Then, set up the <code>ODEProblem</code> exactly as you would in DifferentialEquations.jl. Define the vector field</p><pre><code class="language-julia hljs">function fitz(du, u, p, t)
    a, b, c = p
    du[1] = c * (u[1] - u[1]^3 / 3 + u[2])
    du[2] = -(1 / c) * (u[1] - a - b * u[2])
end</code></pre><p>and then the <code>ODEProblem</code>, with initial value <code>u0</code>, time span <code>tspan</code>, and parameters <code>p</code></p><pre><code class="language-julia hljs">u0 = [-1.0; 1.0]
tspan = (0.0, 20.0)
p = (0.2, 0.2, 3.0)
prob = ODEProblem(fitz, u0, tspan, p)</code></pre><h2 id="Step-2:-Solve-the-problem"><a class="docs-heading-anchor" href="#Step-2:-Solve-the-problem">Step 2: Solve the problem</a><a id="Step-2:-Solve-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Solve-the-problem" title="Permalink"></a></h2><p>To solve the ODE we just use DifferentialEquations.jl&#39;s <code>solve</code> interface, together with one of the algorithms implemented in this package. For now, let&#39;s use <a href="../../solvers/#ProbNumDiffEq.EK1"><code>EK1</code></a>:</p><pre><code class="language-julia hljs">sol = solve(prob, EK1())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: ODE Filter Posterior
t: 267-element Vector{Float64}:
  0.0
  0.021276864853851562
  0.05530062522770621
  0.09069833974374658
  0.13926827781702378
  0.18486670656185625
  0.24179366397911012
  0.29051816272523345
  0.3490769287679599
  0.39571551758025386
  ⋮
 19.52620471671648
 19.57118993725592
 19.618145281565827
 19.669683561096146
 19.72660662373306
 19.789272758467693
 19.860208126620186
 19.94055004101715
 20.0
u: 267-element Vector{Vector{Float64}}:
 [-1.0, 1.0]
 [-0.978397898660792, 1.0098599972789335]
 [-0.9424079091803095, 1.0253304289278915]
 [-0.9028542905882087, 1.0410170752594414]
 [-0.8445349615757094, 1.0618117231749664]
 [-0.7847703259504633, 1.0804970332988895]
 [-0.7018976697192764, 1.102556299329847]
 [-0.622068920127181, 1.1201790771323807]
 [-0.512584623578099, 1.1395948416743362]
 [-0.41230242602460154, 1.1534759756505175]
 ⋮
 [2.0826740294562933, 0.9061101524201192]
 [2.078744560756923, 0.880585842963934]
 [2.073202127513046, 0.8539368332415443]
 [2.0660462633712053, 0.8247002716083859]
 [2.0573291294637492, 0.7924433159689404]
 [2.0471229128144675, 0.7569883434597867]
 [2.0350861534147575, 0.7169394922557054]
 [2.0210436519484105, 0.6717007174964964]
 [2.0104405118668844, 0.6383145073764129]</code></pre><p>That&#39;s it! we just computed a <em>probabilistic numerical</em> ODE solution!</p><h2 id="Step-3:-Analyze-the-solution"><a class="docs-heading-anchor" href="#Step-3:-Analyze-the-solution">Step 3: Analyze the solution</a><a id="Step-3:-Analyze-the-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Analyze-the-solution" title="Permalink"></a></h2><p>Let&#39;s plot the result with <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</p><pre><code class="language-julia hljs">using Plots
plot(sol)</code></pre><img src="1cf85048.svg" alt="Example block output"/><p>Looks good! Looks like the <code>EK1</code> managed to solve the Fitzhugh-Nagumo problem quite well.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>To learn more about plotting ODE solutions, check out the plotting tutorial for DifferentialEquations.jl + Plots.jl provided <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/plot/">here</a>. Most of that works exactly as expected with ProbNumDiffEq.jl.</p></div></div><h3 id="Plot-the-probabilistic-error-estimates"><a class="docs-heading-anchor" href="#Plot-the-probabilistic-error-estimates">Plot the probabilistic error estimates</a><a id="Plot-the-probabilistic-error-estimates-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-the-probabilistic-error-estimates" title="Permalink"></a></h3><p>The plot above looks like a standard ODE solution – but it&#39;s not! The numerical errors are just so small that we can&#39;t see them in the plot, and the probabilistic error estimates are too. We can visualize them by plotting the errors and error estimates directly:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq, Statistics
reference = solve(prob, Vern9(), abstol=1e-9, reltol=1e-9, saveat=sol.t)
errors = reduce(hcat, mean.(sol.pu) .- reference.u)&#39;
error_estimates = reduce(hcat, std.(sol.pu))&#39;
plot(sol.t, errors, label=&quot;error&quot;, color=[1 2], xlabel=&quot;t&quot;, ylabel=&quot;err&quot;)
plot!(sol.t, zero(errors), ribbon=3error_estimates, label=&quot;error estimate&quot;,
      color=[1 2], alpha=0.2)</code></pre><img src="9f9f6075.svg" alt="Example block output"/><h3 id="More-about-the-ProbabilisticODESolution"><a class="docs-heading-anchor" href="#More-about-the-ProbabilisticODESolution">More about the <code>ProbabilisticODESolution</code></a><a id="More-about-the-ProbabilisticODESolution-1"></a><a class="docs-heading-anchor-permalink" href="#More-about-the-ProbabilisticODESolution" title="Permalink"></a></h3><p>The solution object returned by ProbNumDiffEq.jl mostly behaves just like any other <code>ODESolution</code> in DifferentialEquations.jl – with some added uncertainties and related functionality on top. The <code>ProbabilisticODESolution</code> can be indexed with</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol.u[1]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 -1.0
  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol.u[end]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 2.0104405118668844
 0.6383145073764129</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol.t[end]</code><code class="nohighlight hljs ansi" style="display:block;">20.0</code></pre><p>But since <code>sol</code> is a <em>probabilistic numerical</em> ODE solution, it contains a <a href="https://github.com/mschauer/GaussianDistributions.jl">Gaussian</a> distributions over solution values. The marginals of this posterior are stored in <code>sol.pu</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol.pu[end]</code><code class="nohighlight hljs ansi" style="display:block;">Gaussian{Vector{Float64},PSDMatrix{Float64, Matrix{Float64}}}([2.0104405118668844, 0.6383145073764129], 2x2 PSDMatrix{Float64, Matrix{Float64}}; R=[4.819328867073896e-5 0.000150086281654363; -4.209242496334892e-5 -0.00013099898185084177; 4.6624624651022493e-7 6.695624542113227e-6; -9.340635819017074e-8 5.806477585177133e-8; 1.3698832861365067e-6 4.548663507983009e-6; -1.6958383599728362e-7 -5.775663746240759e-6; 0.0 0.0; 0.0 0.0])</code></pre><p>You can compute means, covariances, and standard deviations via Statistics.jl:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Statistics</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mean(sol.pu[5])</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 -0.8445349615757094
  1.0618117231749664</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cov(sol.pu[5])</code><code class="nohighlight hljs ansi" style="display:block;">2x2 PSDMatrix{Float64, Matrix{Float64}}
 Right square root: R=8×2 Matrix{Float64}:
 -2.8014e-6  -1.24815e-7
  0.0         2.74772e-6
  0.0        -2.06464e-21
  0.0        -9.13207e-22
  0.0         1.90066e-19
  0.0         0.0
  0.0         0.0
  0.0         0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; std(sol.pu[5])</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 2.8014003609809637e-6
 2.750553392466558e-6</code></pre><h4 id="Dense-output"><a class="docs-heading-anchor" href="#Dense-output">Dense output</a><a id="Dense-output-1"></a><a class="docs-heading-anchor-permalink" href="#Dense-output" title="Permalink"></a></h4><p>Probabilistic numerical ODE solvers approximate the posterior distribution</p><p class="math-container">\[p \Big( y(t) ~\big|~ y(0) = y_0, \{ \dot{y}(t_i) = f_\theta(y(t_i), t_i) \} \Big),\]</p><p>which describes a posterior not just for the discrete steps but for any <span>$t$</span> in the continuous space <span>$t \in [0, T]$</span>; in classic ODE solvers, this is also known as &quot;interpolation&quot; or &quot;dense output&quot;. The probabilistic solutions returned by our solvers can be interpolated as usual by treating them as functions, but they return Gaussian distributions</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol(0.45)</code><code class="nohighlight hljs ansi" style="display:block;">Gaussian{Vector{Float64},PSDMatrix{Float64, Matrix{Float64}}}([-0.2773821283086789, 1.1675659430627081], 2x2 PSDMatrix{Float64, Matrix{Float64}}; R=[-3.208354407821569e-5 -4.789969845355876e-6; 0.0 1.9264788456676448e-5; 0.0 1.460579017560511e-5; 0.0 1.0839739025995338e-6; 0.0 5.606932635215914e-7; 0.0 0.0; 0.0 0.0; 0.0 0.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mean(sol(0.45))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 -0.2773821283086789
  1.1675659430627081</code></pre><h2 id="Next-steps"><a class="docs-heading-anchor" href="#Next-steps">Next steps</a><a id="Next-steps-1"></a><a class="docs-heading-anchor-permalink" href="#Next-steps" title="Permalink"></a></h2><p>Check out one of the other tutorials:</p><ul><li>&quot;<a href="../dynamical_odes/#Second-Order-ODEs-and-Energy-Preservation">Second Order ODEs and Energy Preservation</a>&quot; explains how to solve second-order ODEs more efficiently while also better preserving energy or other conserved quantities;</li><li>&quot;<a href="../dae/#Solving-DAEs-with-Probabilistic-Numerics">Solving DAEs with Probabilistic Numerics</a>&quot; demonstrates how to solve differential algebraic equations in a probabilistic numerical way.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../dynamical_odes/">Second Order ODEs and Energy Preservation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 12 February 2024 09:11">Monday 12 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
