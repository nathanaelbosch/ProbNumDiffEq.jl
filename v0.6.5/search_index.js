var documenterSearchIndex = {"docs":
[{"location":"filtering/#Gaussian-Filtering-and-Smoothing","page":"Filtering and Smoothing","title":"Gaussian Filtering and Smoothing","text":"","category":"section"},{"location":"filtering/#Predict","page":"Filtering and Smoothing","title":"Predict","text":"","category":"section"},{"location":"filtering/","page":"Filtering and Smoothing","title":"Filtering and Smoothing","text":"ProbNumDiffEq.predict\nProbNumDiffEq.predict!","category":"page"},{"location":"filtering/#ProbNumDiffEq.predict","page":"Filtering and Smoothing","title":"ProbNumDiffEq.predict","text":"predict(x::Gaussian, A::AbstractMatrix, Q::AbstractMatrix)\n\nPrediction step in Kalman filtering for linear dynamics models.\n\nGiven a Gaussian x = mathcalN(μ Σ), compute and return mathcalN(A μ A Σ A^T + Q).\n\nSee also the non-allocating square-root version predict!.\n\n\n\n\n\n","category":"function"},{"location":"filtering/#ProbNumDiffEq.predict!","page":"Filtering and Smoothing","title":"ProbNumDiffEq.predict!","text":"predict!(x_out, x_curr, Ah, Qh, cachemat)\n\nIn-place and square-root implementation of predict which saves the result into x_out.\n\nOnly works with ProbNumDiffEq.SquarerootMatrix types as Ah, Qh, and in the covariances of x_curr and x_out (both of type Gaussian). To prevent allocations, a cache matrix cachemat of size D times 2D (where D times D is the size of Ah and Qh) needs to be passed.\n\nSee also: predict.\n\n\n\n\n\n","category":"function"},{"location":"filtering/#Update","page":"Filtering and Smoothing","title":"Update","text":"","category":"section"},{"location":"filtering/","page":"Filtering and Smoothing","title":"Filtering and Smoothing","text":"ProbNumDiffEq.update\nProbNumDiffEq.update!","category":"page"},{"location":"filtering/#ProbNumDiffEq.update","page":"Filtering and Smoothing","title":"ProbNumDiffEq.update","text":"update(x, measurement, H)\n\nUpdate step in Kalman filtering for linear dynamics models.\n\nGiven a Gaussian x = mathcalN(μ Σ) and a measurement z = mathcalN(hatz S), with S = H Σ H^T, compute\n\nbeginaligned\nK = Σ^P H^T S^-1 \nμ^F = μ + K (0 - hatz) \nΣ^F = Σ - K S K^T\nendaligned\n\nand return an updated state \\mathcal{N}(μ^F, Σ^F). Note that this assumes zero-measurements. When called with ProbNumDiffEq.SquarerootMatrix type arguments it performs the update in Joseph / square-root form.\n\nFor better performance, we recommend to use the non-allocating update!.\n\n\n\n\n\n","category":"function"},{"location":"filtering/#ProbNumDiffEq.update!","page":"Filtering and Smoothing","title":"ProbNumDiffEq.update!","text":"update!(x_out, x_pred, measurement, H, K_cache, M_cache, S_cache)\n\nIn-place and square-root implementation of update which saves the result into x_out.\n\nImplemented in Joseph Form; works best when called with SquarerootMatrix covariances. To prevent allocations, write into caches K_cache and M_cache, both of size D × D, and S_cache of same type as measurement.Σ.\n\nSee also: update.\n\n\n\n\n\n","category":"function"},{"location":"filtering/#Smooth","page":"Filtering and Smoothing","title":"Smooth","text":"","category":"section"},{"location":"filtering/","page":"Filtering and Smoothing","title":"Filtering and Smoothing","text":"ProbNumDiffEq.smooth\nProbNumDiffEq.smooth!","category":"page"},{"location":"filtering/#ProbNumDiffEq.smooth","page":"Filtering and Smoothing","title":"ProbNumDiffEq.smooth","text":"smooth(x_curr, x_next_smoothed, A, Q)\n\nUpdate step of the Kalman smoother, aka. Rauch-Tung-Striebel smoother, for linear dynamics models.\n\nGiven Gaussians x_n = mathcalN(μ_n Σ_n) and x_n+1 = mathcalN(μ_n+1^S Σ_n+1^S), compute\n\nbeginaligned\nμ_n+1^P = A μ_n^F \nP_n+1^P = A Σ_n^F A + Q \nG = Σ_n^S A^T (Σ_n+1^P)^-1 \nμ_n^S = μ_n^F + G (μ_n+1^S - μ_n+1^P) \nΣ_n^S = (I - G A) Σ_n^F (I - G A)^T + G Q G^T + G Σ_n+1^S G^T\nendaligned\n\nand return a smoothed state \\mathcal{N}(μ_n^S, Σ_n^S). When called with ProbNumDiffEq.SquarerootMatrix type arguments it performs the update in Joseph / square-root form.\n\nFor better performance, we recommend to use the non-allocating smooth!.\n\n\n\n\n\n","category":"function"},{"location":"filtering/#ProbNumDiffEq.smooth!","page":"Filtering and Smoothing","title":"ProbNumDiffEq.smooth!","text":"smooth!(x_curr, x_next, Ah, Qh, cache, diffusion=1)\n\nIn-place and square-root implementation of smooth which overwrites x_curr.\n\nImplemented in Joseph form to preserve square-root structure. It requires access to the solvers GaussianODEFilterCache (passed as cache) to prevent allocations.\n\nSee also: smooth.\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Solving-ODEs-with-Probabilistic-Numerics","page":"Introduction to ODE Filters","title":"Solving ODEs with Probabilistic Numerics","text":"","category":"section"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"In this tutorial we solve a simple non-linear ordinary differential equation (ODE) with the probabilistic numerical ODE solvers implemented in this package.","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"note: Note\nIf you never used DifferentialEquations.jl, check out their \"Ordinary Differential Equations\" tutorial on how to solve ordinary differential equations with classic numerical solvers.","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"In this tutorial, we consider a Fitzhugh-Nagumo model described by an ODE of the form","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"beginaligned\ndoty_1 = c (y_1 - fracy_1^33 + y_2) \ndoty_2 = -frac1c (y_1 - a - b y_2)\nendaligned","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"on a time span t in 0 T, with initial value y(0) = y_0. In the following, we","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"define the problem with explicit choices of initial values, integration domains, and parameters,\nsolve the problem with our ODE filters, and\nvisualize the results and the corresponding uncertainties.","category":"page"},{"location":"getting_started/#TL;DR:","page":"Introduction to ODE Filters","title":"TL;DR:","text":"","category":"section"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"using ProbNumDiffEq, Plots\n\nfunction fitz(du, u, p, t)\n    a, b, c = p\n    du[1] = c*(u[1] - u[1]^3/3 + u[2])\n    du[2] = -(1/c)*(u[1] -  a - b*u[2])\nend\nu0 = [-1.0; 1.0]\ntspan = (0., 20.)\np = (0.2, 0.2, 3.0)\nprob = ODEProblem(fitz, u0, tspan, p)\n\nusing Logging; Logging.disable_logging(Logging.Warn) # hide\nsol = solve(prob, EK1())\nLogging.disable_logging(Logging.Debug) # hide\nplot(sol)","category":"page"},{"location":"getting_started/#Step-1:-Defining-the-problem","page":"Introduction to ODE Filters","title":"Step 1: Defining the problem","text":"","category":"section"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"We first import ProbNumDiffEq.jl","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"using ProbNumDiffEq","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"and then set up an ODEProblem exactly as we're used to with DifferentialEquations.jl, by defining the vector field","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"function fitz(du, u, p, t)\n    a, b, c = p\n    du[1] = c*(u[1] - u[1]^3/3 + u[2])\n    du[2] = -(1/c)*(u[1] -  a - b*u[2])\nend\nnothing # hide","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"and then an ODEProblem, with initial value u0, time span tspan, and parameters p","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"u0 = [-1.0; 1.0]\ntspan = (0., 20.)\np = (0.2, 0.2, 3.0)\nprob = ODEProblem(fitz, u0, tspan, p)\nnothing # hide","category":"page"},{"location":"getting_started/#Step-2:-Solving-the-problem","page":"Introduction to ODE Filters","title":"Step 2: Solving the problem","text":"","category":"section"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"To solve the ODE we just use DifferentialEquations.jl's solve interface, together with one of the algorithms implemented in this package. For now, let's use EK1:","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"using Logging; Logging.disable_logging(Logging.Warn) # hide\nsol = solve(prob, EK1())\nLogging.disable_logging(Logging.Debug) # hide\nnothing # hide","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"That's it! we just computed a probabilistic numerical ODE solution!","category":"page"},{"location":"getting_started/#Step-3:-Analyzing-the-solution","page":"Introduction to ODE Filters","title":"Step 3: Analyzing the solution","text":"","category":"section"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"The result of solve is a solution object which can be handled just as in DifferentialEquations.jl. We can access mean values by indexing sol","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"sol[end]","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"or directly via sol.u","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"sol.u[end]","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"and similarly the time steps","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"sol.t[end]","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"But we didn't use probabilstic numerics to just compute means. In fact, sol is a probabilistic numerical ODE solution and it provides Gaussian distributions over solution values. These are stored in sol.pu:","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"sol.pu[end]","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"You can compute means, covariances, and standard deviations via Statistics.jl:","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"using Statistics\nmean(sol.pu[5])\ncov(sol.pu[5])\nstd(sol.pu[5])","category":"page"},{"location":"getting_started/#Dense-output","page":"Introduction to ODE Filters","title":"Dense output","text":"","category":"section"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"Probabilistic numerical ODE solvers approximate the posterior distribution","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"p Big( y(t) mid  doty(t_i) = f_theta(y(t_i) t_i)  Big)","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"which describes a posterior not just for the discrete steps but for any t in the continuous space t in 0 T; in classic ODE solvers, this is also known as \"interpolation\" or \"dense output\". The probabilistic solutions returned by our solvers can be interpolated as usual by treating them as functions, but they return Gaussian distributions","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"sol(0.45)\nmean(sol(0.45))","category":"page"},{"location":"getting_started/#Plotting","page":"Introduction to ODE Filters","title":"Plotting","text":"","category":"section"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"The result can be conveniently visualized through Plots.jl:","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"using Plots\nplot(sol)","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"A more detailed plotting tutorial for DifferentialEquations.jl + Plots.jl is provided here; most of the features work exactly as expected.","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"The uncertainties here are very low compared to the function value so we can't really see them. Just to demonstrate that they're there, let's solve the explicit EK0 solver, low order and higher tolerance levels:","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"using Logging; Logging.disable_logging(Logging.Warn) # hide\nsol = solve(prob, EK0(order=1), abstol=1e-2, reltol=1e-1)\nLogging.disable_logging(Logging.Debug) # hide\nplot(sol, denseplot=false)","category":"page"},{"location":"getting_started/","page":"Introduction to ODE Filters","title":"Introduction to ODE Filters","text":"There it is!","category":"page"},{"location":"solvers/#Solvers-and-Options","page":"Solvers and Options","title":"Solvers and Options","text":"","category":"section"},{"location":"solvers/","page":"Solvers and Options","title":"Solvers and Options","text":"ProbNumDiffEq.jl provides mainly the following two solvers, both based on extended Kalman filtering and smoothing. For the best results we suggest using EK1, but note that it relies on the Jacobian of the vector field.","category":"page"},{"location":"solvers/#Solvers","page":"Solvers and Options","title":"Solvers","text":"","category":"section"},{"location":"solvers/","page":"Solvers and Options","title":"Solvers and Options","text":"All solvers are compatible with DAEs in mass-matrix ODE form, and specialize on second-order ODEs.","category":"page"},{"location":"solvers/","page":"Solvers and Options","title":"Solvers and Options","text":"EK1\nEK0","category":"page"},{"location":"solvers/#ProbNumDiffEq.EK1","page":"Solvers and Options","title":"ProbNumDiffEq.EK1","text":"EK1(; order=3, smooth=true,\n      diffusionmodel=DynamicDiffusion(),\n      initialization=TaylorModeInit(),\n      kwargs...)\n\nGaussian ODE filter with first order vector field linearization.\n\nArguments\n\norder::Integer: Order of the integrated Brownian motion (IBM) prior.\nsmooth::Bool: Turn smoothing on/off; smoothing is required for dense output.\ndiffusionmodel::ProbNumDiffEq.AbstractDiffusion: See Diffusion models and calibration.\ninitialization::ProbNumDiffEq.InitializationScheme: See Initialization.\n\nSome additional kwargs relating to implicit solvers are supported; check out DifferentialEquations.jl's Extra Options page. Right now, we support autodiff, chunk_size, and diff_type. In particular, autodiff=false can come in handy to use finite differences instead of ForwardDiff.jl to compute Jacobians.\n\nReferences\n\n\n\n\n\n","category":"type"},{"location":"solvers/#ProbNumDiffEq.EK0","page":"Solvers and Options","title":"ProbNumDiffEq.EK0","text":"EK0(; order=3, smooth=true,\n      diffusionmodel=DynamicDiffusion(),\n      initialization=TaylorModeInit())\n\nGaussian ODE filter with zeroth order vector field linearization.\n\nArguments\n\norder::Integer: Order of the integrated Brownian motion (IBM) prior.\nsmooth::Bool: Turn smoothing on/off; smoothing is required for dense output.\ndiffusionmodel::ProbNumDiffEq.AbstractDiffusion: See Diffusion models and calibration.\ninitialization::ProbNumDiffEq.InitializationScheme: See Initialization.\n\nReferences\n\n\n\n\n\n","category":"type"},{"location":"solvers/#Diffusion-models-and-calibration","page":"Solvers and Options","title":"Diffusion models and calibration","text":"","category":"section"},{"location":"solvers/","page":"Solvers and Options","title":"Solvers and Options","text":"In a nutshell: \"Dynamic\" diffusion models allow the diffusion to change in-between each solver step and are recommended in combination with adaptive step-sizes. \"Fixed\" diffusion models keep the diffusion constant and can be helpful in fixed-step settings or for debugging by reducing the complexity of the models.","category":"page"},{"location":"solvers/","page":"Solvers and Options","title":"Solvers and Options","text":"For more information on the influence of diffusions, check out","category":"page"},{"location":"solvers/","page":"Solvers and Options","title":"Solvers and Options","text":"N. Bosch, P. Hennig, F. Tronarp: Calibrated Adaptive Probabilistic ODE Solvers (2021)","category":"page"},{"location":"solvers/","page":"Solvers and Options","title":"Solvers and Options","text":"DynamicDiffusion\nFixedDiffusion\nDynamicMVDiffusion\nFixedMVDiffusion","category":"page"},{"location":"solvers/#ProbNumDiffEq.DynamicDiffusion","page":"Solvers and Options","title":"ProbNumDiffEq.DynamicDiffusion","text":"DynamicDiffusion()\n\nRecommended with adaptive steps\n\nA local diffusion parameter is estimated at each step. Works well with adaptive steps.\n\n\n\n\n\n","category":"type"},{"location":"solvers/#ProbNumDiffEq.FixedDiffusion","page":"Solvers and Options","title":"ProbNumDiffEq.FixedDiffusion","text":"FixedDiffusion(; initial_diffusion=1.0, calibrate=true)\n\nRecommended with fixed steps\n\nIf calibrate=true, the probabilistic solution is calibrated once at the end of the solve. An initial diffusion parameter can be passed, but this only has an effect if calibrate=false - which is typically not recommended.\n\n\n\n\n\n","category":"type"},{"location":"solvers/#ProbNumDiffEq.DynamicMVDiffusion","page":"Solvers and Options","title":"ProbNumDiffEq.DynamicMVDiffusion","text":"DynamicMVDiffusion()\n\nOnly works with the EK0\n\nA multi-variate version of DynamicDiffusion, where instead of a scalar a vector-valued diffusion is estimated. When using the EK0, this can be helpful when the scales of the different dimensions vary a lot.\n\n\n\n\n\n","category":"type"},{"location":"solvers/#ProbNumDiffEq.FixedMVDiffusion","page":"Solvers and Options","title":"ProbNumDiffEq.FixedMVDiffusion","text":"FixedMVDiffusion(; initial_diffusion=1.0, calibrate=true)\n\nOnly works with the EK0\n\nA multi-variate version of FixedDiffusion, where instead of a scalar a vector-valued diffusion is estimated. When using the EK0, this can be helpful when the scales of the different dimensions vary a lot.\n\n\n\n\n\n","category":"type"},{"location":"solvers/#Initialization","page":"Solvers and Options","title":"Initialization","text":"","category":"section"},{"location":"solvers/","page":"Solvers and Options","title":"Solvers and Options","text":"TaylorModeInit\nClassicSolverInit","category":"page"},{"location":"solvers/#ProbNumDiffEq.TaylorModeInit","page":"Solvers and Options","title":"ProbNumDiffEq.TaylorModeInit","text":"TaylorModeInit()\n\nRecommended\n\nExact initialization via Taylor-mode automatic differentiation. Uses TaylorIntegration.jl. In case of errors, try ClassicSolverInit.\n\nReferences:\n\nN. Krämer, P. Hennig: Stable Implementation of Probabilistic ODE Solvers (2020)\n\n\n\n\n\n","category":"type"},{"location":"solvers/#ProbNumDiffEq.ClassicSolverInit","page":"Solvers and Options","title":"ProbNumDiffEq.ClassicSolverInit","text":"ClassicSolverInit(; alg=OrdinaryDiffEq.Tsit5(), init_on_du=false)\n\nExact initialization with a classic ODE solver. The solver to be used can be set with the alg keyword argument. init_on_du specifies if ForwardDiff.jl should be used to compute the jacobian and initialize on the exact second derivative.\n\nNot recommended for large solver orders, say order>4.\n\n\n\n\n\n","category":"type"},{"location":"dae/#Solving-DAEs-with-Probabilistic-Numerics","page":"Differential Algebraic Equations","title":"Solving DAEs with Probabilistic Numerics","text":"","category":"section"},{"location":"dae/","page":"Differential Algebraic Equations","title":"Differential Algebraic Equations","text":"ProbNumDiffEq.jl provides probabilistic numerical solvers for differential algebraic equations (DAEs). Currently, we recommend using the semi-implicit EK1 algorithm.","category":"page"},{"location":"dae/","page":"Differential Algebraic Equations","title":"Differential Algebraic Equations","text":"note: Note\nFor a more general tutorial on DAEs, solved with classic solvers, check out the DifferentialEquations.jl DAE tutorial.","category":"page"},{"location":"dae/#Solving-a-Mass-Matrix-DAE-with-the-EK1","page":"Differential Algebraic Equations","title":"Solving a Mass-Matrix DAE with the EK1","text":"","category":"section"},{"location":"dae/","page":"Differential Algebraic Equations","title":"Differential Algebraic Equations","text":"using ProbNumDiffEq, Plots\n\nfunction rober(du,u,p,t)\n  y₁,y₂,y₃ = u\n  k₁,k₂,k₃ = p\n  du[1] = -k₁*y₁ + k₃*y₂*y₃\n  du[2] =  k₁*y₁ - k₃*y₂*y₃ - k₂*y₂^2\n  du[3] =  y₁ + y₂ + y₃ - 1\n  nothing\nend\nM = [1. 0  0\n     0  1. 0\n     0  0  0]\nf = ODEFunction(rober,mass_matrix=M)\nprob_mm = ODEProblem(f, [1.0, 0.0, 0.0], (0.0, 1e5), (0.04, 3e7, 1e4))\nusing Logging; Logging.disable_logging(Logging.Warn) # hide\nsol = solve(prob_mm, EK1(), reltol=1e-8, abstol=1e-8)\nLogging.disable_logging(Logging.Debug) # hide\nplot(sol, xscale=:log10, tspan=(1e-6, 1e5), layout=(3,1), legend=false, ylabel=[\"u₁(t)\" \"u₂(t)\" \"u₃(t)\"], xlabel=[\"\" \"\" \"t\"], denseplot=false)","category":"page"},{"location":"dae/#References","page":"Differential Algebraic Equations","title":"References","text":"","category":"section"},{"location":"dae/","page":"Differential Algebraic Equations","title":"Differential Algebraic Equations","text":"[1] N. Bosch, F. Tronarp, P. Hennig: Pick-and-Mix Information Operators for Probabilistic ODE Solvers (2022) (link)","category":"page"},{"location":"dynamical_odes/#Second-Order-ODEs-and-Energy-Preservation","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"","category":"section"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"In this tutorial we consider an energy-preserving, physical dynamical system, given by a second-order ODE.","category":"page"},{"location":"dynamical_odes/#TL;DR:","page":"Second Order ODEs and Energy Preservation","title":"TL;DR:","text":"","category":"section"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"To efficiently solve second-order ODEs, just define the problem as a SecondOrderODEProblem.\nTo preserve constant quantities, use the ManifoldUpdate callback; same syntax as DiffEqCallback.jl's ManifoldProjection.","category":"page"},{"location":"dynamical_odes/#Simulating-the-Hénon-Heiles-system","page":"Second Order ODEs and Energy Preservation","title":"Simulating the Hénon-Heiles system","text":"","category":"section"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"The Hénon-Heiles model describes the motion of a star around a galactic center, restricted to a plane. It is given by a second-order ODE","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"beginaligned\nddotx = - x - 2 x y \nddoty = y^2 - y - x^2\nendaligned","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"Our goal is to numerically simulate this system on a time span t in 0 T, starting with initial values x(0)=0, y(0) = 01, dotx(0) = 05, doty(0) = 0.","category":"page"},{"location":"dynamical_odes/#Transforming-the-problem-into-a-first-order-ODE","page":"Second Order ODEs and Energy Preservation","title":"Transforming the problem into a first-order ODE","text":"","category":"section"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"A very common approach is to first transform the problem into a first-order ODE by introducing a new variable","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"u = dxdyxy","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"to obtain","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"beginaligned\ndotu_1(t) = - u_3 - 2 u_3 u_4 \ndotu_2(t) = u_4^2 - u_4 - u_4^2 \ndotu_3(t) = u_1 \ndotu_4(t) = u_2\nendaligned","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"This first-order ODE can then be solved using any conventional ODE solver - including our EK1:","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"using ProbNumDiffEq, Plots\n\nfunction Hénon_Heiles(du,u,p,t)\n    du[1] = -u[3] - 2*u[3]*u[4]\n    du[2] = u[4]^2 - u[4] -u[3]^2\n    du[3] = u[1]\n    du[4] = u[2]\nend\nu0, du0 = [0.0, 0.1], [0.5, 0.0]\ntspan = (0.0, 100.0)\nprob = ODEProblem(Hénon_Heiles, [du0; u0], tspan)\nsol = solve(prob, EK1());\nplot(sol, vars=(3,4)) # where `vars=(3,4)` is used to plot x agains y","category":"page"},{"location":"dynamical_odes/#Solving-the-second-order-ODE-directly","page":"Second Order ODEs and Energy Preservation","title":"Solving the second-order ODE directly","text":"","category":"section"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"Instead of first transforming the problem, we can also solve it directly as a second-order ODE, by defining it as a SecondOrderODEProblem.","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"note: Note\nThe SecondOrderODEProblem type is not defined in ProbNumDiffEq.jl but is provided by SciMLBase.jl. For more information, check out the DifferentialEquations.jl documentation on Dynamical, Hamiltonian and 2nd Order ODE Problems.","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"function Hénon_Heiles2(ddu,du,u,p,t)\n    ddu[1] = -u[1] - 2*u[1]*u[2]\n    ddu[2] = u[2]^2 - u[2] -u[1]^2\nend\nprob2 = SecondOrderODEProblem(Hénon_Heiles2, du0, u0, tspan)\nsol2 = solve(prob2, EK1());\nplot(sol2, vars=(3,4))","category":"page"},{"location":"dynamical_odes/#Benchmark:-Solving-second-order-ODEs-is-*faster*","page":"Second Order ODEs and Energy Preservation","title":"Benchmark: Solving second order ODEs is faster","text":"","category":"section"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"Solving second-order ODEs is not just a matter of convenience - in fact, SciMLBase's SecondOrderODEProblem is neatly designed in such a way that all the classic solvers from OrdinaryDiffEq.jl can handle it by solving the corresponding first-order ODE. But, transforming the ODE to first order increases the dimensionality of the problem, and comes therefore at increased computational cost; this also motivates classic specialized solvers for second-order ODEs.","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"The probablistic numerical solvers from ProbNumDiffEq.jl have the same internal state representation for first and second order ODEs; all that changes is the measurement model [1]. As a result, we can use the EK1 both for first and second order ODEs, but it automatically specializes on the latter to provide a 2x performance boost:","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"julia> @btime solve(prob, EK1(order=3), adaptive=false, dt=1e-2);\n  766.312 ms (400362 allocations: 173.38 MiB)\n\njulia> @btime solve(prob2, EK1(order=4), adaptive=false, dt=1e-2);\n  388.301 ms (510676 allocations: 102.78 MiB)","category":"page"},{"location":"dynamical_odes/#Energy-preservation","page":"Second Order ODEs and Energy Preservation","title":"Energy preservation","text":"","category":"section"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"In addition to the ODE given above, we know that the solution of the Hénon-Heiles model has to preserve energy over time. The total energy can be expressed as the sum of the potential and kinetic energies, given by","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"beginaligned\noperatornamePotentialEnergy(xy) = frac12 left( x^2 + y^2 + 2 x^2 y - frac2y^33 right) \noperatornameKineticEnergy(dotx doty) = frac12 left( dotx^2 + doty^2 right)\nendaligned","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"In code:","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"PotentialEnergy(x,y) = 1//2 * (x^2 + y^2 + 2x^2*y - 2//3 * y^3)\nKineticEnergy(dx,dy) = 1//2 * (dx^2 + dy^2)\nE(dx,dy,x,y) = PotentialEnergy(x,y) + KineticEnergy(dx,dy)\nE(u) = E(u...); # convenient shorthand","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"So, let's have a look at how the total energy changes over time when we numerically simulate the Hénon-Heiles model over a long period of time: Standard solve","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"longprob = remake(prob2, tspan=(0.0, 1e3))\nlongsol = solve(longprob, EK1(smooth=false), dense=false)\nplot(longsol.t, E.(longsol.u))","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"It visibly loses energy over time, from an initial 0.12967 to a final 0.12899. Let's fix this to get a physically more meaningful solution.","category":"page"},{"location":"dynamical_odes/#Energy-preservation-with-the-ManifoldUpdate-callback","page":"Second Order ODEs and Energy Preservation","title":"Energy preservation with the ManifoldUpdate callback","text":"","category":"section"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"In the language of ODE filters, preserving energy over time amounts to just another measurement model [1]. The most convenient way of updating on this additional zero measurement with ProbNumDiffEq.jl is with the ManifoldUpdate callback.","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"note: Note\nThe ManifoldUpdate callback can be thought of a probabilistic counterpart to the ManifoldProjection callback provided by DiffEqCallbacks.jl.","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"To do so, first define a (vector-valued) residual function, here chosen to be the difference between the current energy and the initial energy, and build a ManifoldUpdate callback","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"residual(u) = [E(u) - E(du0..., u0...)]\ncb = ManifoldUpdate(residual)","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"Then, solve the ODE with this callback","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"longsol_preserving = solve(longprob, EK1(smooth=false), dense=false, callback=cb)\nplot(longsol.t, E.(longsol.u))\nplot!(longsol_preserving.t, E.(longsol_preserving.u))","category":"page"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"Voilà! With the ManifoldUpdate callback we could preserve the energy over time and obtain a more truthful probabilistic numerical long-term simulation of the Hénon-Heiles model.","category":"page"},{"location":"dynamical_odes/#References","page":"Second Order ODEs and Energy Preservation","title":"References","text":"","category":"section"},{"location":"dynamical_odes/","page":"Second Order ODEs and Energy Preservation","title":"Second Order ODEs and Energy Preservation","text":"[1] N. Bosch, F. Tronarp, P. Hennig: Pick-and-Mix Information Operators for Probabilistic ODE Solvers (2022)","category":"page"},{"location":"index3dae/#Fun-Fact:-Solving-an-Index-3-DAE","page":"-","title":"Fun-Fact: Solving an Index-3 DAE","text":"","category":"section"},{"location":"index3dae/","page":"-","title":"-","text":"The following is based on the \"Automatic Index Reduction of DAEs\" tutorial by ModelingToolkit.jl, which demonstrates how the classic Rodas4 solver fails to solve a DAE due to the fact that it is of index 3; which is why ModelingToolkit's automatic index reduction is so useful. It turns out that our probabilistic numerical solvers can directly solve the index-3 DAE:","category":"page"},{"location":"index3dae/","page":"-","title":"-","text":"using ProbNumDiffEq, LinearAlgebra\nfunction pendulum!(du, u, p, t)\n    x, dx, y, dy, T = u\n    g, L = p\n    du[1] = dx; du[2] = T*x\n    du[3] = dy; du[4] = T*y - g\n    du[5] = x^2 + y^2 - L^2\nend\npendulum_fun! = ODEFunction(pendulum!, mass_matrix=Diagonal([1,1,1,1,0]))\nu0 = [1.0, 0, 0, 0, 0]; p = [9.8, 1]; tspan = (0, 10.0)\npendulum_prob = ODEProblem(pendulum_fun!, u0, tspan, p)\nsol = solve(pendulum_prob, EK1())\nplot(sol)","category":"page"},{"location":"index3dae/","page":"-","title":"-","text":"prob_index3 = ODEProblem(modelingtoolkitize(pendulum_prob), Pair[], tspan)\n\ntraced_sys = modelingtoolkitize(pendulum_prob)\npendulum_sys = structural_simplify(dae_index_lowering(traced_sys))\nprob_index1 = ODEProblem(pendulum_sys, Pair[], tspan)\n\ntraced_sys = modelingtoolkitize(pendulum_prob)\npendulum_sys = structural_simplify(dae_index_lowering(traced_sys))\nprob_odae = ODAEProblem(pendulum_sys, Pair[], tspan)","category":"page"},{"location":"#Probabilistic-Numerical-Differential-Equation-Solvers","page":"Home","title":"Probabilistic Numerical Differential Equation Solvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Banner)","category":"page"},{"location":"","page":"Home","title":"Home","text":"ProbNumDiffEq.jl provides probabilistic numerical solvers to the DifferentialEquations.jl ecosystem. The implemented ODE filters solve differential equations via Bayesian filtering and smoothing and compute not just a single point estimate of the true solution, but a posterior distribution that contains an estimate of its numerical approximation error.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a short intro video, check out our poster presentation at JuliaCon2021.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more probabilistic numerics check out the ProbNum Python package. It implements probabilistic ODE solvers, but also probabilistic linear solvers, Bayesian quadrature, and many filtering and smoothing implementations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Run Julia, enter ] to bring up Julia's package manager, and add the ProbNumDiffEq.jl package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\n(v1.7) pkg> add ProbNumDiffEq.jl","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For a quick introduction check out the \"Solving ODEs with Probabilistic Numerics\" tutorial.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Two extended Kalman filtering-based probabilistic solvers: the explicit EK0 and semi-implicit EK1.\nAdaptive step-size selection (by default with PI control)\nOn-line uncertainty calibration, for multiple different measurement models\nDense output\nSampling from the solution\nCallback support\nConvenient plotting through a Plots.jl recipe\nAutomatic differentiation via ForwardDiff.jl\nSupports arbitrary precision numbers via BigFloats.jl\nSpecialized solvers for second-order ODEs (demo will be added)\nCompatible with DAEs in mass-matrix ODE form (demo will be added)","category":"page"},{"location":"#Benchmarks","page":"Home","title":"Benchmarks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multi-Language Wrapper Benchmark: ProbNumDiffEq.jl vs. OrdinaryDiffEq.jl, Hairer's FORTRAN solvers, Sundials, LSODA, MATLAB, and SciPy.","category":"page"},{"location":"#references","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"N. Bosch, F. Tronarp, P. Hennig: Pick-and-Mix Information Operators for Probabilistic ODE Solvers (2022)\nN. Krämer, N. Bosch, J. Schmidt, P. Hennig: Probabilistic ODE Solutions in Millions of Dimensions (2021)\nN. Bosch, P. Hennig, F. Tronarp: Calibrated Adaptive Probabilistic ODE Solvers (2021)\nF. Tronarp, S. Särkkä, and P. Hennig: Bayesian ODE Solvers: The Maximum A Posteriori Estimate (2021)\nN. Krämer, P. Hennig: Stable Implementation of Probabilistic ODE Solvers (2020)\nH. Kersting, T. J. Sullivan, and P. Hennig: Convergence Rates of Gaussian Ode Filters (2020)\nF. Tronarp, H. Kersting, S. Särkkä, and P. Hennig: Probabilistic Solutions To Ordinary Differential Equations As Non-Linear Bayesian Filtering: A New Perspective (2019)\nM. Schober, S. Särkkä, and P. Hennig: A Probabilistic Model for the Numerical Solution of Initial Value Problems (2018)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A much more detailed list of references, not only on ODE filters but on probabilistic numerics in general, can be found on the probabilistic-numerics.org homepage.","category":"page"}]
}
