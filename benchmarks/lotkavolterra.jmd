# Lotka-Volterra benchmark


!!! note "Summary"
    Lotka-Volterra is a simple, low-dimensional, non-stiff ODE. We see that:
    - For such a low-dimensional problem the EK0 and EK1 have a very similar runtime
      (but note that by using ParameterizedFunctions.jl, the Jacobian of the vector field is available analytically).
    - Orders behave as in classic solvers:
      Use low order for low accuracy, medium order for medium accuracy, high order for high accuracy.
    - _Do not use EK0 with order > 5!_ The adaptive step size selection apparently does not work well for high orders.
    - The default choice of `diffusionmodel=DynamicDiffusion` and `initialization=TaylorModeInit` are probably fine.
    - If you only need to solve for the last time point, do set `smooth=false`, `dense=false`, and `save_everystep=false`.


Benchmark adapted from
[SciMLBenchmarks.jl](https://docs.sciml.ai/SciMLBenchmarksOutput/stable/NonStiffODE/LotkaVolterra_wpd/).

```julia
using LinearAlgebra, Statistics, Distributions
using DiffEqDevTools, ParameterizedFunctions, SciMLBase, OrdinaryDiffEq, Plots
using ProbNumDiffEq

# Plotting theme
theme(:dao;
    markerstrokewidth=0.5,
    legend=:outertopright,
    bottom_margin=5Plots.mm,
    size = (1000, 600),
    xticks = 10.0 .^ (-16:1:16),
)
```

### Lotka-Volterra problem definition

```julia
f = @ode_def LotkaVolterra begin
  dx = a*x - b*x*y
  dy = -c*y + d*x*y
end a b c d
p = [1.5, 1, 3, 1]
tspan = (0.0, 10.0)
u0 = [1.0, 1.0]
prob = ODEProblem{true, SciMLBase.FullSpecialize}(f, u0, tspan, p)

test_sol = solve(prob, Vern7(), abstol=1/10^14, reltol=1/10^14)
plot(test_sol, title="Lotka-Volterra Solution", legend=false, xticks=:auto)
```

## EK0 across orders

### Final timepoint only
```julia
DENSE = false;
SAVE_EVERYSTEP = false;

_setups = [
  "EK0(order=$order)" => Dict(:alg => EK0(order=order, smooth=DENSE))
  for order in 2:7
]

labels = first.(_setups)
setups = last.(_setups)

abstols = 1.0 ./ 10.0 .^ (4:12)
reltols = 1.0 ./ 10.0 .^ (1:9)

wp = WorkPrecisionSet(
    prob, abstols, reltols, setups;
    names = labels,
    appxsol = test_sol,
    dense = DENSE,
    save_everystep = SAVE_EVERYSTEP,
    maxiters = Int(1e7),
)

plot(wp, palette=Plots.palette([:blue, :red], length(_setups)))
```

### Discrete time-series errors (l2)
```julia
DENSE = true;
SAVE_EVERYSTEP = true;

_setups = [
  "EK0(order=$order)" => Dict(:alg => EK0(order=order, smooth=DENSE))
  for order in 2:7
]

labels = first.(_setups)
setups = last.(_setups)

abstols = 1.0 ./ 10.0 .^ (4:12)
reltols = 1.0 ./ 10.0 .^ (1:9)

wp = WorkPrecisionSet(
    prob, abstols, reltols, setups;
    names = labels,
    appxsol = test_sol,
    dense = DENSE,
    save_everystep = SAVE_EVERYSTEP,
    maxiters = Int(1e7),
)

plot(wp, x=:l2, palette=Plots.palette([:blue, :red], length(_setups)))
```

### Interpolation errors (L2)
```julia
plot(wp, x=:L2, palette=Plots.palette([:blue, :red], length(_setups)))
```

## EK1 across orders

### Final timepoint only
```julia
DENSE = false;
SAVE_EVERYSTEP = false;

_setups = [
  "EK1(order=$order)" => Dict(:alg => EK1(order=order, smooth=DENSE))
  for order in 2:7
]

labels = first.(_setups)
setups = last.(_setups)

abstols = 1.0 ./ 10.0 .^ (4:12)
reltols = 1.0 ./ 10.0 .^ (1:9)

wp = WorkPrecisionSet(
    prob, abstols, reltols, setups;
    names = labels,
    appxsol = test_sol,
    dense = DENSE,
    save_everystep = SAVE_EVERYSTEP,
    maxiters = Int(1e7),
)

plot(wp, palette=Plots.palette([:blue, :red], length(_setups)))
```

### Discrete time-series errors (l2)
```julia
DENSE = true;
SAVE_EVERYSTEP = true;

_setups = [
  "EK1(order=$order)" => Dict(:alg => EK1(order=order, smooth=DENSE))
  for order in 2:7
]

labels = first.(_setups)
setups = last.(_setups)

abstols = 1.0 ./ 10.0 .^ (4:12)
reltols = 1.0 ./ 10.0 .^ (1:9)

wp = WorkPrecisionSet(
    prob, abstols, reltols, setups;
    names = labels,
    appxsol = test_sol,
    dense = DENSE,
    save_everystep = SAVE_EVERYSTEP,
    maxiters = Int(1e7),
)

plot(wp, x=:l2, palette=Plots.palette([:blue, :red], length(_setups)))
```

### Interpolation errors (L2)
```julia
plot(wp, x=:L2, palette=Plots.palette([:blue, :red], length(_setups)))
```

## EK0 vs. EK1: Work-Precision

Final timepoint only:
```julia
DENSE = false;
SAVE_EVERYSTEP = false;

_setups = [
  "EK0(order=2)" => Dict(:alg => EK0(order=2, smooth=DENSE))
  "EK0(order=3)" => Dict(:alg => EK0(order=3, smooth=DENSE))
  "EK0(order=4)" => Dict(:alg => EK0(order=4, smooth=DENSE))
  "EK0(order=5)" => Dict(:alg => EK0(order=5, smooth=DENSE))
  "EK1(order=2)" => Dict(:alg => EK1(order=2, smooth=DENSE))
  "EK1(order=3)" => Dict(:alg => EK1(order=3, smooth=DENSE))
  "EK1(order=4)" => Dict(:alg => EK1(order=4, smooth=DENSE))
  "EK1(order=5)" => Dict(:alg => EK1(order=5, smooth=DENSE))
]

labels = first.(_setups)
setups = last.(_setups)

abstols = 1.0 ./ 10.0 .^ (4:12)
reltols = 1.0 ./ 10.0 .^ (1:9)

wp = WorkPrecisionSet(
    prob, abstols, reltols, setups;
    names = labels,
    appxsol = test_sol,
    dense = DENSE,
    save_everystep = SAVE_EVERYSTEP,
    maxiters = Int(1e7),
)

plot(wp, color=[1 1 1 1 2 2 2 2])
```

Interpolation errors (L2):
```julia
DENSE = true;
SAVE_EVERYSTEP = true;

_setups = [
  "EK0(order=2)" => Dict(:alg => EK0(order=2, smooth=DENSE))
  "EK0(order=3)" => Dict(:alg => EK0(order=3, smooth=DENSE))
  "EK0(order=4)" => Dict(:alg => EK0(order=4, smooth=DENSE))
  "EK0(order=5)" => Dict(:alg => EK0(order=5, smooth=DENSE))
  "EK1(order=2)" => Dict(:alg => EK1(order=2, smooth=DENSE))
  "EK1(order=3)" => Dict(:alg => EK1(order=3, smooth=DENSE))
  "EK1(order=4)" => Dict(:alg => EK1(order=4, smooth=DENSE))
  "EK1(order=5)" => Dict(:alg => EK1(order=5, smooth=DENSE))
]

labels = first.(_setups)
setups = last.(_setups)

abstols = 1.0 ./ 10.0 .^ (4:12)
reltols = 1.0 ./ 10.0 .^ (1:9)

wp = WorkPrecisionSet(
    prob, abstols, reltols, setups;
    names = labels,
    appxsol = test_sol,
    dense = DENSE,
    save_everystep = SAVE_EVERYSTEP,
    maxiters = Int(1e7),
)

plot(wp, x=:L2, color=[1 1 1 1 2 2 2 2])
```

## EK0 vs. EK1: Calibration
Final time-point:
```julia
plot(wp, x=:final, y=:chi2_final, color=[1 1 1 1 2 2 2 2], yguide="Chi-squared (final)")

# Should be distributed according to a Chi-squared distribution:
function plot_chisq_interval!(df, q=0.01)
    dist = Chisq(df)
    low, high, mid = quantile(dist, [q, 1-q])..., mean(dist)
    hline!([low, high], linestyle=:dash, color=:black, label="",
           fill_between=[high nothing], fillcolor=:green, fillalpha=0.15)
    hline!([mid], linestyle=:solid, color=:black, label="")
end
plot_chisq_interval!(2)
```

Interpolation:
```julia
plot(wp, x=:L2, y=:chi2_interp, color=[1 1 1 1 2 2 2 2], yguide="Chi-squared (dense)")
plot_chisq_interval!(2*100)
```

## Comparison of the different diffusion models

### EK0

```julia
DENSE = false;
SAVE_EVERYSTEP = false;

_setups = [
  "EK0(3) Dynamic" => Dict(:alg => EK0(order=3, smooth=DENSE, diffusionmodel=DynamicDiffusion()))
  "EK0(5) Dynamic" => Dict(:alg => EK0(order=5, smooth=DENSE, diffusionmodel=DynamicDiffusion()))
  "EK0(3) Fixed" => Dict(:alg => EK0(order=3, smooth=DENSE, diffusionmodel=FixedDiffusion()))
  "EK0(5) Fixed" => Dict(:alg => EK0(order=5, smooth=DENSE, diffusionmodel=FixedDiffusion()))
  "EK0(3) DynamicMV" => Dict(:alg => EK0(order=3, smooth=DENSE, diffusionmodel=DynamicMVDiffusion()))
  "EK0(5) DynamicMV" => Dict(:alg => EK0(order=5, smooth=DENSE, diffusionmodel=DynamicMVDiffusion()))
  "EK0(3) FixedMV" => Dict(:alg => EK0(order=3, smooth=DENSE, diffusionmodel=FixedMVDiffusion()))
  "EK0(5) FixedMV" => Dict(:alg => EK0(order=5, smooth=DENSE, diffusionmodel=FixedMVDiffusion()))
]

labels = first.(_setups)
setups = last.(_setups)

abstols = 1.0 ./ 10.0 .^ (4:12)
reltols = 1.0 ./ 10.0 .^ (1:9)

wp = WorkPrecisionSet(
    prob, abstols, reltols, setups;
    names = labels,
    appxsol = test_sol,
    dense = DENSE,
    save_everystep = SAVE_EVERYSTEP,
    maxiters = Int(1e7),
)

plot(wp, color=[2 2 3 3 4 4 5 5])
```

Calibration:
```julia
plot(wp, x=:final, y=:chi2_final, color=[2 2 3 3 4 4 5 5], yguide="Chi-squared (final)")
plot_chisq_interval!(2)
```

### EK1

```julia
DENSE = false;
SAVE_EVERYSTEP = false;

_setups = [
  "EK1(3) Dynamic" => Dict(:alg => EK1(order=3, smooth=DENSE, diffusionmodel=DynamicDiffusion()))
  "EK1(5) Dynamic" => Dict(:alg => EK1(order=5, smooth=DENSE, diffusionmodel=DynamicDiffusion()))
  "EK1(3) Fixed" => Dict(:alg => EK1(order=3, smooth=DENSE, diffusionmodel=FixedDiffusion()))
  "EK1(5) Fixed" => Dict(:alg => EK1(order=5, smooth=DENSE, diffusionmodel=FixedDiffusion()))
]

labels = first.(_setups)
setups = last.(_setups)

abstols = 1.0 ./ 10.0 .^ (4:12)
reltols = 1.0 ./ 10.0 .^ (1:9)

wp = WorkPrecisionSet(
    prob, abstols, reltols, setups;
    names = labels,
    appxsol = test_sol,
    dense = DENSE,
    save_everystep = SAVE_EVERYSTEP,
    maxiters = Int(1e7),
)

plot(wp, color=[2 2 3 3])
```

Calibration:
```julia
plot(wp, x=:final, y=:chi2_final, color=[2 2 3 3], yguide="Chi-squared (final)")
plot_chisq_interval!(2)
```

## Comparison of the different initialization schemes

```julia
DENSE = false;
SAVE_EVERYSTEP = false;

abstols = 1.0 ./ 10.0 .^ (4:12)
reltols = 1.0 ./ 10.0 .^ (1:9)

orders = (2, 3, 5, 8)
ps = []
for o in orders
    _setups = [
      "EK1($o) TaylorInit" => Dict(:alg => EK1(order=o, smooth=DENSE, initialization=TaylorModeInit(o)))
      "EK1($o) ForwardDiffInit" => Dict(:alg => EK1(order=o, smooth=DENSE, initialization=ForwardDiffInit(o)))
      "EK1($o) SimpleInit" => Dict(:alg => EK1(order=o, smooth=DENSE, initialization=SimpleInit()))
      "EK1($o) ClassicSolverInit" => Dict(:alg => EK1(order=o, smooth=DENSE, initialization=ClassicSolverInit()))
    ]

    labels = first.(_setups)
    setups = last.(_setups)

    wp = WorkPrecisionSet(
        prob, abstols, reltols, setups;
        names = labels,
        appxsol = test_sol,
        dense = DENSE,
        save_everystep = SAVE_EVERYSTEP,
        maxiters = Int(1e7),
    )

    p = plot(wp, color=[2 4 5 6], xticks = 10.0 .^ (-16:1:5), title = "Order $o")
    push!(ps, p)
end
plot(
    ps...,
    layout=(length(orders), 1),
    size = (800, length(orders)*300),
    xlabel=["" "" "" "Error (final)"],
)
```


## Appendix

Computer information:
```julia
using InteractiveUtils
InteractiveUtils.versioninfo()
```

Package Information:
```julia
using Pkg
Pkg.status()
```

And the full manifest:
```julia
Pkg.status(mode=Pkg.PKGMODE_MANIFEST)
```
