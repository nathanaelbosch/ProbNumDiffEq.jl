# ProbNumDiffEq.jl vs. various solver packages

Adapted from
[SciMLBenchmarks.jl multi-language wrapper benchmark](https://docs.sciml.ai/SciMLBenchmarksOutput/stable/MultiLanguage/ode_wrapper_packages/).

```julia
# Imports
using LinearAlgebra, Statistics
using StaticArrays, DiffEqDevTools, ParameterizedFunctions, Plots, SciMLBase, OrdinaryDiffEq
using ODEInterface, ODEInterfaceDiffEq, Sundials, SciPyDiffEq, deSolveDiffEq, LSODA
using LoggingExtras
ODEInterface.loadODESolvers()

using ProbNumDiffEq

# Workaround: SciPyDiffEq's odeint retcode check compares fullout["tcur"] == saveat[end],
# but tcur is the internal step endpoint (e.g. 10.07) which overshoots the requested time.
# Fix: use >= comparison and index into the tcur vector.
include_string(SciPyDiffEq, """
function DiffEqBase.__solve(prob::DiffEqBase.AbstractODEProblem,
        alg::SciPyAlgorithm, timeseries = [], ts = [], ks = [];
        dense = true, dt = nothing,
        dtmax = abs(prob.tspan[2] - prob.tspan[1]),
        dtmin = eps(eltype(prob.tspan)), save_everystep = false,
        saveat = eltype(prob.tspan)[], timeseries_errors = true,
        reltol = 1e-3, abstol = 1e-6, maxiters = 10_000,
        kwargs...)
    p = prob.p
    tspan = prob.tspan
    u0 = prob.u0

    if DiffEqBase.isinplace(prob)
        f = function (t, u)
            du = similar(u)
            prob.f(du, u, p, t)
            du
        end
    else
        f = (t, u) -> prob.f(u, p, t)
    end

    _saveat = isempty(saveat) ? nothing : saveat
    if _saveat isa Array
        __saveat = _saveat
    elseif _saveat isa Number
        __saveat = Array(tspan[1]:_saveat:tspan[2])
    elseif _saveat isa Nothing
        if save_everystep
            __saveat = nothing
        else
            __saveat = [tspan[1], tspan[2]]
        end
    else
        __saveat = Array(_saveat)
    end

    if alg isa odeint
        __saveat === nothing && error("saveat is required for odeint!")
        sol,
        fullout = integrate.odeint(f, u0, __saveat,
            hmax = dtmax,
            rtol = reltol, atol = abstol,
            full_output = 1, tfirst = true,
            mxstep = maxiters)
        tcur = fullout["tcur"]
        retcode = first(tcur) >= __saveat[end] ? ReturnCode.Success : ReturnCode.Failure
        ts = __saveat
        y = sol

        if u0 isa AbstractArray
            timeseries = Vector{typeof(u0)}(undef, length(ts))
            for i in 1:length(ts)
                timeseries[i] = @view y[i, :]
            end
        else
            timeseries = y
        end

    else
        sol = integrate.solve_ivp(f, tspan, u0,
            first_step = dt,
            max_step = dtmax,
            rtol = reltol, atol = abstol,
            t_eval = __saveat,
            dense_output = dense,
            method = string(alg)[13:(end - 2)])
        ts = sol["t"]
        y = sol["y"]
        retcode = sol["success"] == false ? ReturnCode.Failure : ReturnCode.Success

        if u0 isa AbstractArray
            timeseries = Vector{typeof(u0)}(undef, length(ts))
            for i in 1:length(ts)
                timeseries[i] = @view y[:, i]
            end
        else
            timeseries = y
        end
    end

    if !(alg isa odeint) && dense
        _interp = PyInterpolation(sol["sol"])
    else
        _interp = DiffEqBase.LinearInterpolation(ts, timeseries)
    end

    DiffEqBase.build_solution(prob, alg, ts, timeseries,
        interp = _interp,
        dense = dense,
        retcode = retcode,
        timeseries_errors = timeseries_errors)
end
""")


Plots.theme(
    :dao;
    markerstrokewidth=0.5,
    legend=:outertopright,
    margin=5Plots.mm,
    xticks=10.0 .^ (-16:1:16),
    yticks=10.0 .^ (-6:1:5),
)

# Constants used throughout this benchmark as we only consider final values
const DENSE = false # used to decide if we smooth or not
const SAVE_EVERYSTEP = false;

# COLORS and a realted utility
COLORS = Dict(
    "Julia" => :LightGreen,
    "Julia (static)" => :DarkGreen,
    "Hairer" => :Red,
    "SciPy" => :Yellow,
    "deSolve" => :Blue,
    "Sundials" => :Purple,
    "liblsoda" => :Purple,
    "ProbNumDiffEq: EK0" => :Gray30,
    "ProbNumDiffEq: EK1" => :Gray60,
)
tocolor(n) = if split(n, '(')[1] in keys(COLORS)
    COLORS[split(n, '(')[1]]
else
    COLORS[split(n, ':')[1]]
end

# Do not show "deprecated warnings"
deprecated_filter(log_args) = !contains(log_args.message, "deprecated")
filtered_logger = ActiveFilteredLogger(deprecated_filter, global_logger());
```

## Non-Stiff Problem 1: Lotka-Volterra

```julia
f = @ode_def LotkaVolterra begin
  dx = a*x - b*x*y
  dy = -c*y + d*x*y
end a b c d
p = [1.5, 1, 3, 1]
tspan = (0.0, 10.0)
u0 = [1.0, 1.0]
prob = ODEProblem{true,SciMLBase.FullSpecialize()}(f,u0,tspan,p)
staticprob = ODEProblem{false,SciMLBase.FullSpecialize()}(f,SVector{2}(u0),tspan,SVector{4}(p))

sol = solve(prob,Vern7(),abstol=1/10^14,reltol=1/10^14,dense=false)
test_sol = sol
plot(sol, title="Lotka-Volterra Solution", legend=false, xticks=:auto, yticks=:auto)
```

```julia
_setups = [
  "Julia: DP5" => Dict(:alg=>DP5())
  "Julia: Tsit5" => Dict(:alg=>Tsit5())
  "Julia: Vern7" => Dict(:alg=>Vern7())
  "Hairer: dopri5" => Dict(:alg=>ODEInterfaceDiffEq.dopri5())
  "SciPy: RK45" => Dict(:alg=>SciPyDiffEq.RK45())
  "SciPy: LSODA" => Dict(:alg=>SciPyDiffEq.LSODA())
  "SciPy: odeint" => Dict(:alg=>SciPyDiffEq.odeint())
  "deSolve: lsoda" => Dict(:alg=>deSolveDiffEq.lsoda())
  "deSolve: ode45" => Dict(:alg=>deSolveDiffEq.ode45())
  "Sundials: Adams" => Dict(:alg=>Sundials.CVODE_Adams())
  "ProbNumDiffEq: EK0(3)" => Dict(:alg=>EK0(order=3, smooth=DENSE))
  "ProbNumDiffEq: EK0(5)" => Dict(:alg=>EK0(order=5, smooth=DENSE))
  "ProbNumDiffEq: EK1(3)" => Dict(:alg=>EK1(order=3, smooth=DENSE))
  "ProbNumDiffEq: EK1(5)" => Dict(:alg=>EK1(order=5, smooth=DENSE))
  "ProbNumDiffEq: EK1(8)" => Dict(:alg=>EK1(order=8, smooth=DENSE))
]

labels = first.(_setups)
setups = last.(_setups)
colors = tocolor.(labels) |> permutedims

abstols = 1.0 ./ 10.0 .^ (6:13)
reltols = 1.0 ./ 10.0 .^ (3:10)

wp = with_logger(filtered_logger) do
    WorkPrecisionSet(
        [prob, staticprob], abstols, reltols, setups;
        names = labels,
        appxsol = [test_sol, test_sol],
        dense = DENSE,
        save_everystep = SAVE_EVERYSTEP,
        numruns = 10,
        maxiters = Int(1e7),
        timeseries_errors = false,
        verbose = false,
    )
end

plot(wp, title = "Non-stiff 1: Lotka-Volterra", color = colors)
```

## Non-Stiff Problem 2: Rigid Body

```julia
f = @ode_def RigidBodyBench begin
  dy1  = -2*y2*y3
  dy2  = 1.25*y1*y3
  dy3  = -0.5*y1*y2 + 0.25*sin(t)^2
end
u0 = [1.0;0.0;0.9]
tspan = (0.0, 10.0)
prob = ODEProblem{true,SciMLBase.FullSpecialize()}(f,u0,tspan)
staticprob = ODEProblem{false,SciMLBase.FullSpecialize()}(f,SVector{3}(u0),tspan)
sol = solve(prob,Vern7(),abstol=1/10^14,reltol=1/10^14,dense=false)
test_sol = sol
plot(sol, title="Rigid Body Solution", legend=false, xticks=:auto, yticks=:auto)
```

```julia
_setups = [
  "Julia: DP5" => Dict(:alg=>DP5())
  "Julia: Tsit5" => Dict(:alg=>Tsit5())
  "Julia: Vern7" => Dict(:alg=>Vern7())
  "Hairer: dopri5" => Dict(:alg=>dopri5())
  "SciPy: RK45" => Dict(:alg=>SciPyDiffEq.RK45())
  "SciPy: LSODA" => Dict(:alg=>SciPyDiffEq.LSODA())
  "SciPy: odeint" => Dict(:alg=>SciPyDiffEq.odeint())
  "deSolve: lsoda" => Dict(:alg=>deSolveDiffEq.lsoda())
  "deSolve: ode45" => Dict(:alg=>deSolveDiffEq.ode45())
  "Sundials: Adams" => Dict(:alg=>CVODE_Adams())
  "ProbNumDiffEq: EK0(3)" => Dict(:alg=>EK0(order=3, smooth=DENSE))
  "ProbNumDiffEq: EK0(5)" => Dict(:alg=>EK0(order=5, smooth=DENSE))
  "ProbNumDiffEq: EK1(3)" => Dict(:alg=>EK1(order=3, smooth=DENSE))
  "ProbNumDiffEq: EK1(5)" => Dict(:alg=>EK1(order=5, smooth=DENSE))
  "ProbNumDiffEq: EK1(8)" => Dict(:alg=>EK1(order=8, smooth=DENSE))
]

labels = first.(_setups)
setups = last.(_setups)
colors = tocolor.(labels) |> permutedims

abstols = 1.0 ./ 10.0 .^ (6:13)
reltols = 1.0 ./ 10.0 .^ (3:10)

wp = with_logger(filtered_logger) do
    WorkPrecisionSet(
        [prob,staticprob], abstols, reltols, setups;
        names = labels,
        appxsol = [test_sol, test_sol],
        dense = DENSE,
        save_everystep = SAVE_EVERYSTEP,
        numruns = 10,
        maxiters = Int(1e7),
        timeseries_errors = false,
        verbose = false
    )
end

plot(wp, title = "Non-stiff 2: Rigid-Body", color = colors)
```

## Stiff Problem 1: ROBER

```julia
rober = @ode_def begin
  dy₁ = -k₁*y₁+k₃*y₂*y₃
  dy₂ =  k₁*y₁-k₂*y₂^2-k₃*y₂*y₃
  dy₃ =  k₂*y₂^2
end k₁ k₂ k₃
u0 = [1.0,0.0,0.0]
p = [0.04,3e7,1e4]
prob = ODEProblem{true,SciMLBase.FullSpecialize()}(rober,u0,(0.0,1e5),p)
staticprob = ODEProblem{false,SciMLBase.FullSpecialize()}(rober,SVector{3}(u0),(0.0,1e5),SVector{3}(p))
sol = solve(prob,CVODE_BDF(),abstol=1/10^14,reltol=1/10^14,dense=false)
test_sol = sol
plot(sol, title="ROBER Solution", legend=false, xlims=(1e0, 1e5), xticks=:auto, yticks=:auto)
```

```julia
_setups = [
  "Julia: Rosenbrock23" => Dict(:alg=>Rosenbrock23())
  "Julia: Rodas4" => Dict(:alg=>Rodas4())
  "Julia: Rodas5" => Dict(:alg=>Rodas5())
  "Hairer: rodas" => Dict(:alg=>rodas())
  "Hairer: radau" => Dict(:alg=>radau())
  "SciPy: LSODA" => Dict(:alg=>SciPyDiffEq.LSODA())
  "SciPy: BDF" => Dict(:alg=>SciPyDiffEq.BDF())
  "SciPy: odeint" => Dict(:alg=>SciPyDiffEq.odeint())
  "deSolve: lsoda" => Dict(:alg=>deSolveDiffEq.lsoda())
  "Sundials: CVODE" => Dict(:alg=>CVODE_BDF())
  "ProbNumDiffEq: EK1(3)" => Dict(:alg=>EK1(order=3, smooth=DENSE))
  "ProbNumDiffEq: EK1(5)" => Dict(:alg=>EK1(order=5, smooth=DENSE))
]

labels = first.(_setups)
setups = last.(_setups)
colors = tocolor.(labels) |> permutedims

abstols = 1.0 ./ 10.0 .^ (5:12)
reltols = 1.0 ./ 10.0 .^ (2:9)

wp = with_logger(filtered_logger) do
    WorkPrecisionSet(
        [prob, staticprob], abstols, reltols, setups;
        names = labels,
        dense = DENSE,
        verbose = false,
        save_everystep = SAVE_EVERYSTEP,
        appxsol = [test_sol, test_sol],
        maxiters=Int(1e5)
    )
end

plot(wp, title = "Stiff 1: ROBER", color = colors)
```

## Stiff Problem 2: HIRES

```julia
f = @ode_def Hires begin
  dy1 = -1.71*y1 + 0.43*y2 + 8.32*y3 + 0.0007
  dy2 = 1.71*y1 - 8.75*y2
  dy3 = -10.03*y3 + 0.43*y4 + 0.035*y5
  dy4 = 8.32*y2 + 1.71*y3 - 1.12*y4
  dy5 = -1.745*y5 + 0.43*y6 + 0.43*y7
  dy6 = -280.0*y6*y8 + 0.69*y4 + 1.71*y5 -
           0.43*y6 + 0.69*y7
  dy7 = 280.0*y6*y8 - 1.81*y7
  dy8 = -280.0*y6*y8 + 1.81*y7
end

u0 = zeros(8)
u0[1] = 1
u0[8] = 0.0057
prob = ODEProblem{true,SciMLBase.FullSpecialize()}(f,u0,(0.0,321.8122))
staticprob = ODEProblem{false,SciMLBase.FullSpecialize()}(f,SVector{8}(u0),(0.0,321.8122))

sol = solve(prob,Rodas5(),abstol=1/10^14,reltol=1/10^14, dense=false)
test_sol = sol
plot(sol, title="HIRES Solution", legend=false, xticks=:auto, yticks=:auto)
```

```julia
_setups = [
  "Julia: Rosenbrock23" => Dict(:alg=>Rosenbrock23())
  "Julia: Rodas4" => Dict(:alg=>Rodas4())
  "Julia: radau" => Dict(:alg=>RadauIIA5())
  "Hairer: rodas" => Dict(:alg=>rodas())
  "Hairer: radau" => Dict(:alg=>radau())
  "SciPy: LSODA" => Dict(:alg=>SciPyDiffEq.LSODA())
  "SciPy: BDF" => Dict(:alg=>SciPyDiffEq.BDF())
  "SciPy: odeint" => Dict(:alg=>SciPyDiffEq.odeint())
  "deSolve: lsoda" => Dict(:alg=>deSolveDiffEq.lsoda())
  "Sundials: CVODE" => Dict(:alg=>CVODE_BDF())
  "ProbNumDiffEq: EK1(2)" => Dict(:alg=>EK1(order=2, smooth=DENSE))
  "ProbNumDiffEq: EK1(3)" => Dict(:alg=>EK1(order=3, smooth=DENSE))
  "ProbNumDiffEq: EK1(5)" => Dict(:alg=>EK1(order=5, smooth=DENSE))
]

labels = first.(_setups)
setups = last.(_setups)
colors = tocolor.(labels) |> permutedims

abstols = 1.0 ./ 10.0 .^ (5:10)
reltols = 1.0 ./ 10.0 .^ (1:6)

wp = with_logger(filtered_logger) do
    WorkPrecisionSet(
        [prob, staticprob], abstols, reltols, setups;
        names = labels,
        dense = false,
        verbose = false,
        save_everystep = false,
        appxsol = [test_sol, test_sol],
        maxiters = Int(1e5),
        numruns=100
    )
end

plot(wp, title = "Stiff 2: Hires", color=colors)
```


## Appendix
```julia, echo=false
include("utils.jl")
appendix()
```
